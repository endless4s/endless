import Dependencies.*
import sbtversionpolicy.Compatibility.None

val scala213 = "2.13.16"
val scala3 = "3.7.2"

val commonSettings = Seq(
  wartremoverExcluded += sourceManaged.value,
  Compile / compile / wartremoverErrors ++= Warts.allBut(
    Wart.Any,
    Wart.Nothing,
    Wart.ImplicitParameter,
    Wart.ImplicitConversion,
    Wart.Throw,
    Wart.DefaultArguments
  ),
  scalaVersion := scala213,
  crossScalaVersions := Seq(scala213, scala3),
  libraryDependencies ++= (CrossVersion.partialVersion(scalaVersion.value) match {
    case Some((2, _)) =>
      Seq(compilerPlugin("org.typelevel" % "kind-projector" % "0.13.3" cross CrossVersion.full))
    case _ => Nil
  }),
  Compile / scalacOptions ++= Seq("-Xfatal-warnings"),
  Compile / scalacOptions ++= (CrossVersion.partialVersion(scalaVersion.value) match {
    case Some((3, _)) => Seq("-Xkind-projector:underscores")
    case Some((2, _)) =>
      Seq("-Xsource:3", "-P:kind-projector:underscore-placeholders", "-Xlint:unused")
    case _ => Nil
  })
)

inThisBuild(
  List(
    organization := "io.github.endless4s",
    homepage := Some(url("https://github.com/endless4s/endless")),
    licenses := List("MIT License" -> url("http://opensource.org/licenses/mit-license.php")),
    developers := List(
      Developer(
        "jchapuis",
        "Jonas Chapuis",
        "me@jonaschapuis.com",
        url("https://jonaschapuis.com")
      )
    ),
    sonatypeCredentialHost := "s01.oss.sonatype.org",
    sonatypeProjectHosting := Some(
      xerial.sbt.Sonatype.GitHubHosting("endless4s", "endless", "me@jonaschapuis.com")
    ),
    Global / onChangedBuildSource := ReloadOnSourceChanges,
    PB.protocVersion := "3.17.3", // works on Apple Silicon,
    versionPolicyIntention := Compatibility.None,
    versionScheme := Some("early-semver"),
    versionPolicyIgnoredInternalDependencyVersions := Some(
      "^\\d+\\.\\d+\\.\\d+\\+\\d+".r
    ), // Support for versions generated by sbt-dynver
    coverageExcludedPackages := "<empty>;endless.test.*"
  )
)

lazy val core = (project in file("core"))
  .settings(commonSettings *)
  .settings(
    libraryDependencies ++= cats ++ catsEffectKernel ++ log4cats ++
      (catsLaws ++ catsEffectLaws ++ catsEffect ++ catsTestkit ++ catsEffectTestKit ++ mUnit ++ catsEffectMUnit ++ scalacheckEffect ++ kittens)
        .map(_ % Test)
  )
  .settings(name := "endless-core")

lazy val akkaRuntime = (project in file("akka-runtime"))
  .settings(commonSettings *)
  .dependsOn(core)
  .settings(
    libraryDependencies ++= catsEffectStd ++ akkaProvided ++ log4cats ++ scalapbCustomizations ++ (mUnit :+ akkaTypedTestkit % akkaVersion)
      .map(_ % Test)
  )
  .settings(
    Project.inConfig(Test)(sbtprotoc.ProtocPlugin.protobufConfigSettings),
    Compile / PB.targets := Seq(
      scalapb.gen() -> (Compile / sourceManaged).value / "scalapb"
    ),
    Test / PB.targets := Seq(
      scalapb.gen() -> (Test / sourceManaged).value / "scalapb"
    )
  )
  .settings(name := "endless-runtime-akka")

lazy val pekkoRuntime = (project in file("pekko-runtime"))
  .settings(commonSettings *)
  .dependsOn(core)
  .settings(
    libraryDependencies ++= catsEffectStd ++ pekkoProvided ++ log4cats ++ scalapbCustomizations ++ (mUnit ++ logback :+ pekkoTypedTestkit % pekkoVersion)
      .map(_ % Test)
  )
  .settings(
    Compile / PB.targets := Seq(
      scalapb.gen() -> (Compile / sourceManaged).value / "scalapb"
    ),
    Test / PB.targets := Seq(
      scalapb.gen() -> (Test / sourceManaged).value / "scalapb"
    )
  )
  .settings(name := "endless-runtime-pekko")

lazy val circeHelpers = (project in file("circe"))
  .settings(commonSettings *)
  .dependsOn(core)
  .settings(
    libraryDependencies ++= circe ++ mUnit.map(_ % Test)
  )
  .settings(name := "endless-circe-helpers")

lazy val scodecHelpers = (project in file("scodec"))
  .settings(commonSettings *)
  .settings(scalaVersion := scala3, crossScalaVersions := Nil) // only scala3 for scodec
  .dependsOn(core)
  .settings(libraryDependencies ++= scodecCore ++ mUnit.map(_ % Test))
  .settings(name := "endless-scodec-helpers")

lazy val protobufHelpers = (project in file("protobuf"))
  .settings(commonSettings *)
  .dependsOn(core)
  .settings(
    libraryDependencies ++= scalapbCustomizations ++ mUnit.map(_ % Test)
  )
  .settings(name := "endless-protobuf-helpers")
  .settings(
    Compile / PB.targets := Seq(
      scalapb.gen() -> (Compile / sourceManaged).value / "scalapb"
    ),
    Test / PB.targets := Seq(
      scalapb.gen() -> (Test / sourceManaged).value / "scalapb"
    )
  )

lazy val example = (project in file("example"))
  .settings(commonSettings *)
  .dependsOn(core, akkaRuntime, pekkoRuntime, circeHelpers, protobufHelpers)
  .settings(
    libraryDependencies ++= catsEffect ++ http4s ++ blaze ++ akka ++ pekko ++ scalapbCustomizations ++ akkaTest ++ pekkoTest ++ logback ++ (mUnit ++ catsEffectMUnit ++ scalacheckEffect ++ log4catsTesting)
      .map(_ % Test)
  )
  .settings(name := "endless-example", run / fork := true, publish / skip := true)
  .settings(
    Project.inConfig(Test)(sbtprotoc.ProtocPlugin.protobufConfigSettings),
    Compile / PB.targets := Seq(
      scalapb.gen() -> (Compile / sourceManaged).value / "scalapb"
    ),
    Test / PB.targets := Seq(
      scalapb.gen() -> (Test / sourceManaged).value / "scalapb"
    )
  )

// Generate API documentation per module, as documented in https://www.scala-sbt.org/sbt-site/api-documentation.html#scaladoc-from-multiple-projects

// Create one configuration per module
val Core = config("core")
val Protobuf = config("protobuf")
val Circe = config("circe")
val Scodec = config("scodec")
val AkkaRuntime = config("akka-runtime")
val PekkoRuntime = config("pekko-runtime")

// For each module define its package prefix and path in documentation API
val scaladocSiteProjects = List(
  core -> (Core, "endless", "core"),
  protobufHelpers -> (Protobuf, "endless.protobuf", "protobuf"),
  scodecHelpers -> (Scodec, "endless.scodec", "scodec"),
  circeHelpers -> (Circe, "endless.circe", "circe"),
  akkaRuntime -> (AkkaRuntime, "endless.runtime.akka", "akka-runtime"),
  pekkoRuntime -> (PekkoRuntime, "endless.runtime.pekko", "pekko-runtime")
)

lazy val documentation = (project in file("documentation"))
  .enablePlugins(
    ParadoxMaterialThemePlugin,
    SitePreviewPlugin,
    ParadoxPlugin,
    ParadoxSitePlugin,
    SiteScaladocPlugin
  )
  .settings(
    paradoxProperties ++= (
      scaladocSiteProjects.map { case (_, (_, pkg, path)) =>
        s"scaladoc.${pkg}.base_url" -> s"api/${path}"
      }.toMap
    ),
    paradoxProperties ++= List(
      ("akka.min.version" -> akkaVersion),
      ("pekko.min.version" -> pekkoVersion)
    ).toMap,
    scaladocSiteProjects.flatMap { case (project, (conf, _, path)) =>
      SiteScaladocPlugin.scaladocSettings(
        conf,
        project / Compile / packageDoc / mappings,
        s"api/${path}"
      )
    },
    Compile / paradoxProperties ++= Map(
      "project.description" -> "Scala library to describe event sourced entities using tagless-final algebras, running with built-in implementations for Akka.",
      "project.title" -> "Endless4s",
      "project.image" -> "https://endless4s.github.io/logo-open-graph.png"
    ),
    Compile / paradoxMaterialTheme := {
      val theme = (Compile / paradoxMaterialTheme).value
      val repository =
        (ThisBuild / sonatypeProjectHosting).value.get.scmInfo.browseUrl.toURI
      theme
        .withRepository(repository)
        .withFont("Overpass", "Overpass Mono")
        .withLogo("logo-symbol-only.svg")
        .withFavicon("favicon.png")
        .withSocial(repository)
        .withColor("blue grey", "red")
        .withGoogleAnalytics("G-KKHFXG4VB4")
    }
  )

lazy val root = project
  .in(file("."))
  .aggregate(core, akkaRuntime, pekkoRuntime, circeHelpers, scodecHelpers, protobufHelpers, example)
  .dependsOn(example)
  .settings(commonSettings *)
  .settings(crossScalaVersions := Nil)
  .settings(publish / skip := true)
  .settings(name := "endless")

Compile / mainClass := Some("endless.example.app.pekko.Main")
